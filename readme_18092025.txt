readme – Pilot “Siano AI”

Versione: 19/09/2025 (revisione aggiornata)

Cos’è

“Siano AI” è una homepage comunale “viva” che:

racconta Siano (storia, galleria, festività);

elenca gli esercenti aderenti con pagine dedicate (QR);

integra un assistente AI che risponde usando solo dati locali (JSON).

È un pilot: low-cost (static hosting), modulare, facilmente estendibile.

Tecnologie

Vite + React + TypeScript

Tailwind (classi inline; nessun config custom)

Framer Motion (transizioni/AnimatePresence)

lucide-react (icone)

Netlify: hosting + Functions (endpoint AI: /.netlify/functions/ask)

Dati JSON in public/data (home.json, venues.json, <slug>.json)

Facoltativo: VITE_AI_ENDPOINT per puntare a un endpoint AI esterno

AI upstream attuale: Hugging Face (Chat Completions router)
→ chiave in HF_TOKEN su Netlify

Architettura (semplificata)
public/
  city/            # immagini/logo Comune
  data/
    home.json      # dati homepage comunale
    venues.json    # open data esercenti
    <slug>.json    # dati singolo esercente (catalogo/menu/config/chat)
src/
  App.tsx
  main.tsx
  HomePage.tsx     # UI principale: HERO, tabs, scroll-pad stabile
  SianoVenue.tsx   # pagina esercente
  ChatWidget.tsx   # chat Comune/esercente; CTA; quick replies; autoscroll
  ai/
    ask.ts         # fallback locale (senza LLM) – usato dal widget
netlify/
  functions/
    ask.js         # endpoint AI online (hardening: throttle, retry, 429/503)
package.json, vite.config.ts

Dati chiave
/public/data/home.json (Comune)

cityName, logoUrl, heroTitle, heroSubtitle, heroImages

about, festivities, project, pilot, gallery

openData (link JSON/CSV esercenti)

social, footer, theme (accent cobalto)

assistant: enabled, label, panelTitle, slugForQA: "home", initialMessage

chat:

quickReplies: bottoni rapidi

faq: Q/A fisse

ctas: array link (es. Sito, Open Data) → mostrate nella chat della home

municipal (aggiunta importante):

hoursShort: riassunto orari uffici comunali

address: indirizzo uffici

contacts: telefono/whatsapp ecc. (chiavi accettate: phone, telefono, tel, mobile, cell, phoneNumber, whatsapp, wa)

notes

Nota: la home NON ha config.phone/whatsapp/mapUrl. I pulsanti “Chiama / Indicazioni / WhatsApp” sulla home compaiono solo se previsti in chat.ctas.

/public/data/<slug>.json (Esercente)

config: name, hours, address, phone, whatsapp, mapUrl, assistantLabel

story: descrizione testo

menu (inteso come catalogo/servizi):

specials (opz.)

categories[].items[] con price/tags/fav

chat: quickReplies, faq, ctas (opz.)

Se mancano chat.ctas, la chat deriva automaticamente le CTA da config (Chiama / WhatsApp / Indicazioni).

Comportamento chat: Online vs Offline
1) Online (Netlify Function ask.js)

Il widget chiama /.netlify/functions/ask (o VITE_AI_ENDPOINT se impostato).

La Function rileva profilo (Comune vs Esercente), compatta i dati JSON e istruisce il modello a usare solo i dati forniti.
Se un’informazione non esiste nel JSON → “Non disponibile” (no allucinazioni).

Output conciso (circa 90 parole max), tono istituzionale, con CTA coerenti:

Comune: CTA da home.json > chat.ctas (es. Sito, Open Data)

Esercente: CTA da config (o chat.ctas se presenti)

Hardening:

Throttle per IP (token bucket)

Auto-retry su 429/5xx (con jitter)

Timeout fetch verso l’AI

Cache in-memory dei JSON per 60s

Mappatura errori → 429 (rate limit) / 503 (servizio indisponibile)
Il widget, su !ok, ricade nel fallback locale (UI non si blocca).

2) Offline (fallback locale in ChatWidget.tsx)

Principio aggiornato: reliance 90% modello AI. Il locale interviene solo quando:

l’endpoint fallisce / non risponde / è offline;

per micro-fix deterministico sulla home per gli orari del Comune.

Cosa copre il fallback locale ora:

Comune (slug = "home")

Orari uffici comunali:
‣ micro-fix deterministico se l’utente chiede “orari/orario/apertura/chiusura” e menziona Comune/uffici (hoursShort da municipal)
‣ regex intent aggiornata: orar? copre orari/orario

Contatti/Telefono/WhatsApp: lettura da:

home.json > municipal.contacts (chiavi elastiche, vedi sopra)

fallback su config (se mai presente)

Indirizzo: municipal.address (o fallback config.address se esistesse)

Esercente

Orari/indirizzo/contatti da config

Catalogo: suggerimenti da menu.categories[].items[] (filtri semplici: es. “veg”, “senza lattosio”, “piccante”)

Cosa NON copre più il deterministico (by design):

Topic generici/ambigui non mappati: in offline risponde come “navigazione” (suggerisce chip/argomenti) senza inventare contenuti.

Lingue: il fallback è semplice; la copertura multilingua è demandata soprattutto all’AI online.

Componenti
HomePage.tsx

Carica home.json e venues.json

Applica tema (blu cobalto), favicon, titolo

Tabs: “Siano”, “Progetto pilota”, “Esercenti” (scroll-pad stabile)

Galleria a card con hover

Festività: mostra 3 elementi; toggle “tutte/meno”; shuffle singolo se ≥6

Monta ChatWidget con slug="home"

SianoVenue.tsx

Carica /data/<slug>.json

Render intestazione (logo/nome), story, catalogo (categorie+items)

CTA “Chiama/WhatsApp/Indicazioni” da config o chat.ctas

Monta ChatWidget con stesso slug

ChatWidget.tsx

Carica /data/<slug>.json client-side

Prima tenta l’endpoint AI; se fallisce, fallback locale (stretto)

Micro-fix home (orari Comune) + estrazione contatti robusta (municipal.contacts)

Intent hours con orar? (copre orario/orari)

Autoscroll

CTA precedence: props.ctas → json.chat.ctas → (derivate da config) → []

Comune (slug="home"): mostra solo chat.ctas

Esercente: se chat.ctas mancano, CTA derivate da config

netlify/functions/ask.js

Endpoint AI con hardening (throttle/retry/timeout/cache)

Prompt strictly “only local data”

Output conciso + CTA coerenti

Error mapping 429/503 (il widget gestisce il fallback)

Comandi (sviluppo/deploy)

Install: npm ci

Dev: npm run dev

Build: npm run build

Preview locale: npm run preview

Netlify

Build command: npm run build

Publish dir: dist

Functions: netlify/functions

Env:

HF_TOKEN (Hugging Face)

VITE_AI_ENDPOINT (opz.) per endpoint AI alternativo

Dominio

Pilot: *.netlify.app

Produzione: dominio dedicato (CNAME + HTTPS)

UX/Linee guida

Tono istituzionale, sintetico

Cobalto uniforme su FAB, tab attivi, badge e bottoni accent

Home: CTA limitate a quelle esplicite nel JSON

Accessibilità: contrasto, mobile-first, hit-area generose

Mobile: launcher chat non copre CTA principali; rispetto safe-area

Troubleshooting rapido

“Telefono non indicato” sulla home, ma è nel JSON
→ Verifica che il numero sia in home.json > municipal.contacts con una delle chiavi supportate:
phone, telefono, tel, mobile, cell, phoneNumber.
Per WhatsApp: whatsapp, wa.
Il fallback locale ora li legge correttamente anche offline.

La chat dice sempre “Gli orari non sono indicati”
→ Su home, la micro-fix risponde solo se la domanda è Hours-intent e cita Comune/uffici.
Assicurati che municipal.hoursShort sia valorizzato e che la query menzioni comune/municip/uffic.
Altrimenti, online risponderà l’AI (se l’upstream è ok).

Endpoint AI in errore/timeout
→ Il widget passa in modalità offline e mostra il badge “AI offline”.
Riprova; alza tier HF o configura VITE_AI_ENDPOINT se necessario.

CTA non compaiono sulla home
→ La home non ha config.phone/whatsapp/mapUrl. Aggiungi CTA esplicite in home.json > chat.ctas.

Stile pulsanti diverso tra home/esercenti
→ Assicurati che le CSS var di tema siano caricate; il widget usa outline cobalto e bottone accent coerenti.

To-do (pilot)

Ampliare home.json > chat.faq (orari/contatti uffici, link utili)

Sezione “Eventi” con JSON dedicato e card (mostra tutte/meno)

Script di validazione JSON (URL, campi obbligatori, prezzi numerici)

(Facolt.) Estrarre il fallback locale in modulo condiviso e riusarlo anche lato Function

Dopo il pilot (scaling)

Onboarding esercenti: modello JSON + guida 1 pagina

Mini-backoffice (anche Google Sheet → build statico)

Dominio/branding definitivo

Analytics privacy-first (Plausible/Umami)

DPIA/Note privacy se la chat si estende a servizi con dati personali

Modalità ibrida (flag): consentire risposte generali con disclaimer e/o ricerca web con citazioni (valutare col Comune)

Hugging Face tier: considerare Inference Endpoints / Space dedicata

Testing checklist (rapida)

home.json:

municipal.hoursShort, municipal.address, municipal.contacts.* presenti?

chat.ctas presenti? (home)

<slug>.json esercente:

config.{phone,whatsapp,mapUrl} compilati?

chat.ctas mancano? → derivazione automatica

Online:

ask.js risponde entro timeout? (controlla 429/503 nei log)

Offline:

Home: “orari Comune/uffici” → usa hoursShort

“telefono/whatsapp/contatti” → usa municipal.contacts

Esercente: ricade su config, catalogo suggerito ok

Brief rapido per nuova chat (incolla all’inizio)

Sto lavorando al pilot “Siano AI”: React/TypeScript (Vite), ChatWidget e dati in JSON (home.json per il Comune; <slug>.json per ciascun esercente). La home usa tabs con scroll stabile e tema cobalto; l’assistente legge i dati dal JSON dello slug e mostra CTA da chat.ctas (Comune) o da config (esercenti). Hosting Netlify + Functions per ask.
L’assistente si affida 90% al modello AI online; fallback locale stretto solo su errore/offline (incluse micro-fix: orari Comune e contatti da municipal.contacts). Chiedo aiuto pratico (bugfix, UX, JSON, Netlify Functions) senza regressioni.

Owner / Status

Owner: Dott. Davide Romano (Ingegneria Informatica e dell’Automazione; Accenture, Milano)

Stato: pilot online su Netlify
Prossimi step: presentazione al Comune, feedback, onboarding 3–5 esercenti